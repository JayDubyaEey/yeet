package cli

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"sync"
	"time"

	"github.com/spf13/cobra"
	"golang.org/x/sync/errgroup"

	"github.com/JayDubyaEey/yeet/internal/config"
	"github.com/JayDubyaEey/yeet/internal/envwriter"
	"github.com/JayDubyaEey/yeet/internal/provider/azcli"
	"github.com/JayDubyaEey/yeet/internal/ui"
)

func newFetchCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "fetch",
		Short: "Fetch secrets and write .env and docker.env",
		RunE: func(cmd *cobra.Command, args []string) error {
			return runFetch(cmd.Context())
		},
	}
	return cmd
}

func newRefreshCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "refresh",
		Short: "Refresh .env and docker.env from Key Vault",
		RunE: func(cmd *cobra.Command, args []string) error {
			// Same as fetch; optionally warm token
			if err := azcli.NewDefault().WarmToken(cmd.Context()); err != nil {
				ui.Warn("could not warm token: %v", err)
			}
			return runFetch(cmd.Context())
		},
	}
	return cmd
}

func runFetch(ctx context.Context) error {
	cfg, err := config.Load(configPath)
	if err != nil {
		return err
	}
	vault := cfg.KeyVaultName
	if vaultOverride != "" {
		vault = vaultOverride
	}

	prov := azcli.NewDefault()
	if err := prov.EnsureLoggedIn(ctx); err != nil {
		return fmt.Errorf("not logged in to Azure CLI: %w (run: yeet login)", err)
	}

	// Fetch secrets concurrently
	type result struct{ key, value string }
	results := make([]result, 0, len(cfg.Mappings))
	missing := make([]string, 0)

	g, gctx := errgroup.WithContext(ctx)
	sem := make(chan struct{}, 6) // concurrency limit
	var mu sync.Mutex
	for envKey, mapping := range cfg.Mappings {
		envKey := envKey
		mapping := mapping
		sem <- struct{}{}
		g.Go(func() error {
			defer func() { <-sem }()
			val, err := prov.GetSecret(gctx, vault, mapping.Secret)
			if err != nil {
				// Distinguish missing from other errors if possible
				if azcli.IsNotFound(err) {
					mu.Lock(); missing = append(missing, fmt.Sprintf("%s -> %s", envKey, mapping.Secret)); mu.Unlock()
					return nil
				}
				return fmt.Errorf("failed to get secret %s for %s: %w", mapping.Secret, envKey, err)
			}
			mu.Lock(); results = append(results, result{key: envKey, value: val}); mu.Unlock()
			return nil
		})
	}
	if err := g.Wait(); err != nil {
		return err
	}
	if len(missing) > 0 {
		ui.Error("missing %d secrets in vault %s:", len(missing), vault)
		sort.Strings(missing)
		for _, m := range missing { ui.Error("  - %s", m) }
		return errors.New("one or more secrets are missing")
	}

	// Build maps for .env and docker.env
	envMap := map[string]string{}
	dockerMap := map[string]string{}
	for _, r := range results {
		envMap[r.key] = r.value
	}
	for envKey, mapping := range cfg.Mappings {
		if mapping.Docker != nil {
			dockerMap[envKey] = *mapping.Docker
		} else {
			dockerMap[envKey] = envMap[envKey]
		}
	}

	// Merge with existing files to retain unknown keys
	existingEnv, _ := envwriter.ReadKeyValues(".env")
	existingDocker, _ := envwriter.ReadKeyValues("docker.env")
	finalEnv := envwriter.MergeRetainUnknowns(envMap, existingEnv, cfg.Mappings)
	finalDocker := envwriter.MergeRetainUnknowns(dockerMap, existingDocker, cfg.Mappings)

	// Warn about unmapped keys
	unmappedEnv := envwriter.UnmappedKeys(existingEnv, cfg.Mappings)
	unmappedDocker := envwriter.UnmappedKeys(existingDocker, cfg.Mappings)
	if len(unmappedEnv) > 0 || len(unmappedDocker) > 0 {
		ui.Warn("retaining %d keys not defined in env.config.json", len(unmappedEnv)+len(unmappedDocker))
		for _, k := range unmappedEnv { ui.Warn("  - .env: %s", k) }
		for _, k := range unmappedDocker { ui.Warn("  - docker.env: %s", k) }
	}

	header := fmt.Sprintf("# Generated by yeet\n# Source: %s\n# Vault: %s\n# Generated: %s\n", configPath, vault, time.Now().Format(time.RFC3339))
	if err := envwriter.WriteEnvFile(".env", finalEnv, header); err != nil {
		return err
	}
	if err := envwriter.WriteEnvFile("docker.env", finalDocker, header); err != nil {
		return err
	}

	ui.Success("wrote .env and docker.env (%d keys)", len(finalEnv))
	return nil
}

